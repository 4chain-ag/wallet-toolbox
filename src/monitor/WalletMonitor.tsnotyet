
/**
 * Background task to make sure transactions are processed, transaction proofs are received and propagated,
 * and potentially that reorgs update proofs that were already received.
 */
export class DojoWatchman {
    static createDefaultDojoWatchmanOptions(): DojoWatchmanOptions {
        const o: DojoWatchmanOptions = {
            ...CwiExternalServices.createDefaultOptions(),
            msecsWaitPerMerkleProofServiceReq: 500,
            taskRunWaitMsecs: 5000,
            abandonedMsecs: 1000 * 60 * 5,
            unprovenAttemptsLimitTest: 2016,
            unprovenAttemptsLimitMain: 144,
        }
        return o
    }

    options: DojoWatchmanOptions
    storage: DojoStorageApi
    chaintracks: ChaintracksClientApi
    chain: Chain
    services: CwiExternalServices

    headersSubscriptionId?: string = undefined
    reorgsSubscriptionId?: string = undefined

    
    constructor(public dojo: DojoBase, options?: DojoWatchmanOptions) {
        this.options = options || DojoWatchman.createDefaultDojoWatchmanOptions()
        this.storage = dojo.storage
        this.chaintracks = dojo.chaintracks
        this.chain = dojo.options.chain
        this.services = new CwiExternalServices(this.options)

    }

    /**
     * _tasks are typically run by the scheduler but may also be run by runTask.
     */
    _tasks: DojoWatchmanTask[] = []
    /**
     * _otherTasks can be run by runTask but not by scheduler.
     */
    _otherTasks: DojoWatchmanTask[] = []
    _tasksRunning = false
    
    /**
     * Default tasks with settings appropriate for a single user Dojo
     * possibly with sync'ing enabled
     */
    addDefaultTasks() : void {
        this._tasks.push(new DojoTaskSendWaiting(this))
        this._tasks.push(new DojoTaskCheckForProofs(this))
        this._tasks.push(new DojoTaskNotifyOfProofs(this))
        this._tasks.push(new DojoTaskFailAbandoned(this))
        this._otherTasks.push(new DojoTaskSyncWhenIdle(this))
        this._otherTasks.push(new DojoTaskCheckProofs(this))
    }
    
    /**
     * Tasks appropriate for multi-user dojos
     * without sync'ing enabled.
     */
    addMultiUserDojoTasks() : void {
        const seconds = 1000
        const minutes = seconds * 60
        const hours = minutes * 60
        const days = hours * 24
        this._tasks.push(new DojoTaskSendWaiting(this, 8 * seconds, 7 * seconds)) // Check every 8 seconds but must be 7 seconds old
        this._tasks.push(new DojoTaskCheckForProofs(this, 2 * hours)) // Every two hours if no block found
        this._tasks.push(new DojoTaskNotifyOfProofs(this, 5 * minutes)) // Every 5 minutes, supports marking nosend reqs as invalid
        this._tasks.push(new DojoTaskFailAbandoned(this, 8 * minutes))
        this._tasks.push(new DojoTaskPurge(this, {
            purgeCompleted: true,
            purgeFailed: true,
            purgeCompletedDelay: 14 * days,
            purgeFailedDelay: 14 * days
        }, 6 * hours))
        this._otherTasks.push(new DojoTaskValidate(this))
        this._otherTasks.push(new DojoTaskCheckProofs(this, 1000 * 60 * 60 * 4))
    }

    addTask(task: DojoWatchmanTask) : void {
        if (this._tasks.some(t => t.name === task.name))
            throw new ERR_BAD_REQUEST(`task ${task.name} has already been added.`)
        this._tasks.push(task)
    }
    
    removeTask(name: string) : void {
        this._tasks = this._tasks.filter(t => t.name !== name)
    }

    async setupChaintracksListeners() : Promise<void> {
        try {
            // If the chaintracks supplied supports it, listen for new headers and reorgs.
            const chaintracks = this.chaintracks as ChaintracksApi
            this.headersSubscriptionId = await chaintracks.subscribeHeaders(this.processNewBlockHeader.bind(this))
            this.reorgsSubscriptionId = await chaintracks.subscribeReorgs(this.processReorg.bind(this))
        } catch (err) {
            /* this chaintracks doesn't support event subscriptions */
        }
    }
    
    async runTask(name: string) : Promise<void> {
        let task = this._tasks.find(t => t.name === name)
        if (!task)
            task = this._otherTasks.find(t => t.name === name)
        if (task) {
            await task.asyncSetup()
            await task.runTask()
        }
    }

    async startTasks() : Promise<void> {
        
        if (this._tasksRunning)
            throw new ERR_BAD_REQUEST('watchman tasks are already runnining.')
        
        this._tasksRunning = true

        if (!this.headersSubscriptionId) {
            await this.setupChaintracksListeners()
        }
        
        for (const t of this._tasks) {
            try {
                await t.asyncSetup()
            } catch(eu: unknown) {
                const e = CwiError.fromUnknown(eu)
                console.log(`watchman task ${t.name} asyncSetup error ${e.code} ${e.description}`)
            }
            if (!this._tasksRunning) break
        }

        for (;;) {

            if (!this._tasksRunning) break

            // console.log(`${new Date().toISOString()} tasks review triggers`)

            const tasksToRun: DojoWatchmanTask[] = []
            const now = new Date().getTime()
            for (const t of this._tasks) {
                try {
                    if (t.trigger(now).run) tasksToRun.push(t)
                } catch(eu: unknown) {
                    const e = CwiError.fromUnknown(eu)
                    console.log(`watchman task ${t.name} trigger error ${e.code} ${e.description}`)
                }
            }

            for (const ttr of tasksToRun) {

                try {
                    console.log(`${new Date().toISOString()} running  ${ttr.name}`)
                    await ttr.runTask()
                } catch(eu: unknown) {
                    const e = CwiError.fromUnknown(eu)
                    console.log(`watchman task ${ttr.name} runTask error ${e.code} ${e.description}`)
                } finally {
                    ttr.lastRunMsecsSinceEpoch = new Date().getTime()
                }

                if (!this._tasksRunning) break

            }

            if (!this._tasksRunning) break

            // console.log(`${new Date().toISOString()} tasks run, waiting...`)
            await wait(this.options.taskRunWaitMsecs)
        }
    }
    
    stopTasks() : void {
        this._tasksRunning = false
    }

    /**
     * For each spendable output in the 'default' basket of the authenticated user,
     * verify that the output script, amount, vout and txid match that of an output
     * still in the mempool of at least one service provider.
     * 
     * @returns object with invalidSpendableOutputs array. A good result is an empty array. 
     */
    async confirmSpendableOutputs() : Promise<{ invalidSpendableOutputs: DojoOutputApi[] }> {
        if (!this.dojo.isAuthenticated)
            throw new ERR_BAD_REQUEST('confirmSpendableUtxos requires authentication')

        const userId = this.dojo.userId
        const defaultBasket = verifyOne(await this.dojo.storage.findOutputBaskets({ userId, name: 'default' }))
        const where: Partial<DojoOutputApi> = {
            userId,
            basketId: defaultBasket.basketId,
            spendable: true
        }
        const outputs = await (await this.storage.findOutputs(where))
        const invalidSpendableOutputs: DojoOutputApi[] = []
        for (let i = outputs.length - 1; i >= 0; i--) {
            const o = outputs[i]
            const oid = verifyId(o.outputId)
            if (o.spendable) {
                let ok = false
                if (o.outputScript && o.outputScript.length > 0) {
                    const r = await this.services.getUtxoStatus(o.outputScript, this.chain, 'script')
                    if (r.status === 'success' && r.isUtxo && r.details?.length > 0) {
                        const tx = await this.storage.findTransactionId(o.transactionId)
                        if (tx && tx.txid && r.details.some(d => d.txid === tx.txid && d.amount === o.amount && d.index === o.vout)) {
                            ok = true
                        }
                    }
                }
                if (!ok)
                    invalidSpendableOutputs.push(o)
            }
        }
        return { invalidSpendableOutputs }
    }

    // Update transaction records where there is an associated proven_txs record:
    // - set Proof to standardized proof
    // - set truncatedExternalInputs to ''
    // - set unconfirmedChainLength to 0
    // - makes a watchman_events note of this to avoid doing it again...
    async updateTransactionsTableProofs() {
        // See if already done...
        const event = {event: 'updateTransactionTableProofs'}
        const wes = await this.storage.findWatchmanEvents(event)
        if (wes && wes.length > 0) return

        const limit = 100
        let offset = 0
        for (;;) {
            const txs = await this.storage.findTransactions({}, undefined, { limit, offset })
            for (const tx of txs) {
                if (!tx.provenTxId) continue
                
                const proven = await this.storage.findProvenTxId(tx.provenTxId)
                if (!proven) continue

                const proofString = ProvenTx.proofString(proven)
                
                await this.storage.updateTransaction(verifyId(tx.transactionId), {
                    truncatedExternalInputs: '',
                    unconfirmedInputChainLength: 0,
                    // Skip this when clients learn to access through DojoProvenTxApi table.
                    proof: proofString
                    // When clients learn to access through DojoProvenTxApi table...
                    // rawTransaction: null
                })
                console.log(`link transaction ${tx.transactionId} ${tx.txid} to proven_tx ${proven.provenTxId} and update proof, turncatedExternalInputs`)
            }
            if (txs.length < limit) break
            offset += limit
        }
        
        // Note that this has been done on this database
        await this.storage.insertWatchmanEvent(event)
    }

    async initialDatabaseReview() : Promise<void> {
        // See if already done...
        const event = {event: 'initialDatabaseReview'}
        const wes = await this.storage.findWatchmanEvents(event, { limit: 1 })
        if (wes && wes.length > 0) event.event = 'reviewWithoutProvenTxId'
        
        const r1 = await checkCompletedProofs(this.storage, this.chaintracks)
        console.log(`${r1.checked} proofs checked: ${r1.extractedProofs} provenTxs extracted, ${r1.invalidProofs} invalid`)
        const r2 = await checkCompletedWithoutProofs(this.storage)
        console.log(`${r2.missingProofs} missing proofs: ${r2.available} provenTxs available, ${r2.proofReqsAdded} provenTxReqs added`)
        
        // Note that this has been done on this database
        await this.storage.insertWatchmanEvent(event)
    }

    /**
     * Using an array of proof providing services, attempt to process each outstanding record
     * in Dojo's `proven_tx_reqs` table.
     *
     * Must manage switching services when a service goes down,
     * and when a service imposes rate limits,
     * and when a proof is not yet available,
     * and when a request is invalid,
     * and maintain history of attempts,
     * and report / handle overloads,
     * and notifiy relevant parties when successful.
     *
     * Updates history, attempts, status
     */
    async processProvenTxReqs(): Promise<void> {

        const limit = 100
        let offset = 0
        for (; ;) {
            const reqs = await this.storage.findProvenTxReqs({}, ['unknown'], { limit, offset })
            await this.getProofs(reqs)
            if (reqs.length < limit) break
            offset += limit
        }
        
        offset = 0
        for (; ;) {
            const reqs = await this.storage.findProvenTxReqs({ notified: false }, DojoProvenTxReqTerminalStatus, { limit, offset })
            await this.notifyOfProvenTx(reqs)
            if (reqs.length < limit) break
            offset += limit
        }
    }

    /**
     * Process an array of 'completed' or 'invalid' status DojoProvenTxReqApi 
     * 
     * Records are deleted.
     * 
     * Should be called with requests after a delay to purge completed work.
     *
     * @param reqs 
     */
    async processCompletedOrInvalid(reqs: DojoProvenTxReqApi[]) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const req of reqs) {
            /* */
            if (req.status === 'completed' || req.status === 'invalid') {
                await this.storage.deleteProvenTxReq({ provenTxReqId: req.provenTxReqId })
            }
        }
    }

    /**
     * Process an array of 'unsent' status DojoProvenTxReqApi 
     * 
     * Send rawTx to transaction processor(s), requesting proof callbacks when possible.
     * 
     * Set status 'invalid' if req is invalid.
     * 
     * Set status to 'callback' on successful network submission with callback service.
     * 
     * Set status to 'unmined' on successful network submission without callback service.
     * 
     * Add mapi responses to database table if received.
     * 
     * Increments attempts if sending was attempted.
     *
     * @param reqApis 
     */
    async processUnsent(reqApis: DojoProvenTxReqApi[], indent = 0) : Promise<string> {
        let log = ''
        for (let i = 0; i < reqApis.length; i++) {
            const reqApi = reqApis[i]
            log += ' '.repeat(indent)
            log += `${i} reqId ${reqApi.provenTxReqId} txid ${reqApi.txid}: `
            if (reqApi.status !== 'unsent') {
                log += `status now ${reqApi.status}\n`
                continue
            }
            const req = new ProvenTxReq(reqApi)
            const reqs: ProvenTxReq[] = []
            if (req.batch) {
                // Make sure wew process entire batch together for efficient beef generation
                const batchReqApis = await this.dojo.storage.findProvenTxReqs({ batch: req.batch, status: 'unsent' })
                for (const bra of batchReqApis) {
                    // Remove any matching batchReqApis from reqApis
                    const index = reqApis.findIndex(ra => ra.provenTxReqId === bra.provenTxReqId)
                    if (index > -1) reqApis.slice(index, index + 1);
                    // And add to reqs being processed now:
                    reqs.push(new ProvenTxReq(bra))
                }
            } else {
                // Just a single non-batched req...
                reqs.push(req)
            }

            const r = await this.dojo.attemptToPostReqsToNetwork(reqs)
        }
        return log
    }

    lastNewHeader: BlockHeader | undefined
    lastNewHeaderWhen: Date | undefined

    /**
     * Process new chain header event received from Chaintracks
     * 
     * Kicks processing 'unconfirmed' and 'unmined' request processing.
     *
     * @param reqs 
     */
    processNewBlockHeader(header: BlockHeader) : void {
        const h = header
        this.lastNewHeader = h
        this.lastNewHeaderWhen = new Date()
        console.log(`Watchman notified of new block header ${h.height}`)
        // Nudge the proof checker to try again.
        DojoTaskCheckForProofs.checkNow = true
    }

    /**
     * Process reorg event received from Chaintracks
     * 
     * Reorgs can move recent transactions to new blocks at new index positions.
     * Affected transaction proofs become invalid and must be updated.
     * 
     * It is possible for a transaction to become invalid.
     *
     * Coinbase transactions always become invalid.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processReorg(depth: number, oldTip: BlockHeader, newTip: BlockHeader) : void {
        /* */
    }

    /**
     * Process an array of 'callback' data received from transaction processors.
     * 
     * `callbackID` values are matched to requests.
     * 
     * Set status 'invalid' if req is invalid.
     *
     * Set status to 'notifying' when callback includes a valid proof.
     * 
     * Set status to 'unmined' if additional callbacks are not expected.
     * 
     * Add mapi responses to database table if received.
     * 
     * Increments attempts.
     *
     * @param reqs 
     */
    async processCallback(callbacks: SentTxCallbackApi[]) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const callback of callbacks) {
            /* */
        }
    }

    /**
     * Process an array of DojoProvenTxReqApi (typically with status 'unmined' or 'unknown')
     * 
     * If req is invalid, set status 'invalid'
     * 
     * Verify the requests are valid, lookup proofs or updated transaction status using the array of getProofServices,
     * 
     * When proofs are found, create new DojoProvenTxApi records and transition the requests' status to 'unconfirmed' or 'notifying',
     * depending on chaintracks succeeding on proof verification. 
     *
     * Increments attempts if proofs where requested.
     *
     * @param reqs 
     * @returns reqs partitioned by status
     */
    async getProofs(reqs: DojoProvenTxReqApi[], indent = 0, countsAsAttempt = false, ignoreStatus = false)
    : Promise<{
        proven: DojoProvenTxReqApi[],
        invalid: DojoProvenTxReqApi[],
        log: string
    }> {
        const proven: DojoProvenTxReqApi[] = []
        const invalid: DojoProvenTxReqApi[] = []

        let log = ''
        for (const reqApi of reqs) {
            log += ' '.repeat(indent)
            log += `reqId ${reqApi.provenTxReqId} txid ${reqApi.txid}: `
            
            if (!ignoreStatus &&
                reqApi.status !== 'callback' &&
                reqApi.status !== 'unmined' &&
                reqApi.status !== 'unknown' &&
                reqApi.status !== 'unconfirmed' &&
                reqApi.status !== 'nosend' &&
                reqApi.status !== 'sending') {
                log += `status of '${reqApi.status}' is not ready to be proven.\n`
                continue
            }

            const req = new ProvenTxReq(reqApi)

            if (Number.isInteger(req.provenTxId)) {
                log += `Already linked to provenTxId ${req.provenTxId}.\n`
                req.notified = false
                req.status = 'completed'
                await req.updateStorage(this.storage)
                proven.push(reqApi)
                continue
            }
            
            log += '\n'

            let reqIsValid = false
            if (req.rawTx) {
                const txid = asString(doubleSha256BE(req.rawTx))
                if (txid === req.txid)
                    reqIsValid = true
            }

            if (!reqIsValid) {
                log += ` rawTx doesn't hash to txid. status => invalid.\n`
                req.notified = false
                req.status = 'invalid'
                await req.updateStorage(this.storage)
                invalid.push(reqApi)
                continue
            }

            const limit = this.chain === 'main' ? this.options.unprovenAttemptsLimitMain : this.options.unprovenAttemptsLimitTest
            if (!ignoreStatus && req.attempts > limit) {
                log += ` too many failed attempts ${req.attempts}\n`
                req.notified = false
                req.status = 'invalid'
                await req.updateStorage(this.storage)
                invalid.push(reqApi)
                continue
            }

            const since = new Date()

            let r: GetMerkleProofResultApi
            let ptx: ProvenTx | undefined

            // External services will try multiple providers until one returns a proof,
            // or they all fail.
            // There may also be an array of proofs to consider when a transaction
            // is recently mined and appears in orphan blocks in addition to active chain blocks.
            // Since orphan blocks can end up on chain again, multiple proofs has value.
            //
            // On failure, there may be a mapi response, or an error.
            //
            // The proofs returned are considered sequentially, validating and chaintracks confirming.
            //
            // If a good proof is found, proceed to using it.
            //
            // When all received proofs fail, force a bump to the next service provider and try
            // one more time.
            //
            r = await this.services.getMerkleProof(req.txid, this.chain)
            ptx = await ProvenTx.fromReq(req, r, this.chaintracks, countsAsAttempt && req.status !== 'nosend')

            if (r.proof && !ptx) {
                r = await this.services.getMerkleProof(req.txid, this.chain, true )
                ptx = await ProvenTx.fromReq(req, r, this.chaintracks, countsAsAttempt && req.status !== 'nosend')
            }

            // fromReq may have set status to unknown (a service returned no proof) or unconfirmed (a proof failed chaintracks lookup)
            // if ptx is valid, it means the final service attempted returned a valid proof that was confirmed.

            if (ptx) {
                const p = ptx
                await this.storage.transaction(async trx => {
                    const p0 = verifyOneOrNone(await this.storage.findProvenTxs({ txid: p.txid }, trx))
                    if (!ptx) throw new ERR_INTERNAL()
                    p.provenTxId = p0 ? p0.provenTxId : await this.storage.insertProvenTx(ptx.toApi(), trx)
                    req.provenTxId = p.provenTxId
                })
                // We have a provenTx record, queue the notifications.
                req.status = 'completed'
                req.notified = false
            } else if (countsAsAttempt && req.status !== 'nosend') {
                req.attempts++
            }

            await req.updateStorage(this.storage)
            await req.refreshFromStorage(this.storage)

            log += req.historyPretty(since, indent + 2) + '\n'

            if (req.status === 'completed') proven.push(req.api)
            if (req.status === 'invalid') invalid.push(req.api)
        }
        
        return { proven, invalid, log }
    }

    /**
     * Process an array of 'notifying' status DojoProvenTxReqApi 
     *
     * notifying: proven_txs record added, while notifications are being processed.
     * 
     * When a proof is received for a transaction, make the following updates:
     *   1. Set the provenTxId column
     *   2. Set the proof column to a stringified copy of the proof in standard form until no longer needed.
     *   3. Set unconfirmedInputChainLength to zero
     *   4. Set truncatedExternalInputs to '' (why not null?)
     *   5. Set rawTransaction to null when clients access through provenTxId instead...
     * 
     * Finally set the req status to 'completed' which will clean up the record after a period of time.
     * 
     * @param reqs 
     */
    async notifyOfProvenTx(reqs: DojoProvenTxReqApi[], indent = 0)
    : Promise<{ notified: DojoProvenTxReqApi[], log: string }>
    {
        const notified: DojoProvenTxReqApi[] = []

        let log = ''
        for (const reqApi of reqs) {
            log += ' '.repeat(indent)
            log += `reqId ${reqApi.provenTxReqId} txid ${reqApi.txid}: `

            if (reqApi.notified) {
                log += `Already notified.\n`
                continue
            }
            
            const since = new Date()
            const req = new ProvenTxReq(reqApi)
            try {
                log += "\n" + await req.processNotifications(this.dojo, undefined, undefined, indent + 2)
            } catch (eu: unknown) {
                const e = CwiError.fromUnknown(eu)
                log += e.message
            }

            log += '\n' + req.historyPretty(since, indent + 2) + '\n'

            notified.push(reqApi)
        }

        return { notified, log }
    }
    
    /**
     * Review all completed transactions to confirm that the transaction amount makes sense based on undestood data protocols:
     * 
     * Balance displayed by MetaNet Client is sum of owned spendable outputs IN THE 'default' BASKET.
     * It is NOT the sum of completed transaction amounts for userId.
     * Transaction amount value appears to be critical in capturing external value effect (inputs and outputs) of each transaction.
     * Transaction isOutgoing seems to be incorrect sometimes???
     * Output 'change' column appears to be unused, always 0. Instead 'purpose' = 'change' appears to be used. Actual value is either 'change' or null currently.
     * Output 'providedBy' column is currently only 'dojo', 'you', or null.
     * Output 'tracked' ????
     * Output 'senderIdentityKey' is currently often an uncompressed key
     * 
     * A standard funding account from satoshi shopper adds 'purpose' = 'change' outputs
     * 
     * Relevant schema columns and conventions:
     * - owned outputs: outputs where output.userId = transaction.userId
     * - commission: commissions where commission.transactionId = transaction.transactionId, there is no outputs record for commissions, max one per transaction(?)
     * - owned input: owned output where output.transactionId != transaction.transactionId, marked by redeemedOutputs in truncatedExternalInputs when under construction and then by outputs.spentBy column when completed???
     * - 
     * Case 1: Normal Spend
     *   amount = -(input - mychange)
     *   spent = owned outputs with purpose null or != 'change'
     *   txIn = sum of output.spentBy = transactionId, output.userId = userId outputs
     *   txOut = sum of new owned outputs (change) + sum
     *   transaction inputs are all owned outputs, all new owned outputs are marked purpose = 'change'
     * 
     * 
     * 
 
select txid, transactionId, amount, input, spent, mychange, commission, (input - spent - mychange - commission) as fee, if(-amount = input - mychange, 'ok', "???") as F
from
(select 
ifnull((select sum(o.amount) from outputs as o where o.spentBy = t.transactionId), 0) as 'input',
ifnull((select sum(o.amount) from outputs as o where o.transactionId = t.transactionId and (purpose != 'change' or purpose is null)), 0) as 'spent',
ifnull((select sum(o.amount) from outputs as o where o.transactionId = t.transactionId and purpose = 'change'), 0) as 'mychange',
ifnull((select sum(c.satoshis) from commissions as c where c.transactionId = t.transactionId), 0) as 'commission',
t.transactionId, t.amount, t.txid from transactions as t where t.userId = 213 and t.status = 'completed' and isOutgoing = 1 order by transactionId) as vals
;

        THIS IS A WORK IN PROGRESS, PARTS ARE KNOWN TO BE INACCURATE
     */
    async reviewTransactionAmounts() {
        const storage = this.dojo.storage
        const limit = 100;

        const users = await storage.findUsers({})
        for (const u of users) {

            const userId = verifyId(u.userId)
            console.log('userId =', userId)

            let offset = 0;
            for (; ;) {
                const allSpendableOutputs = await storage.findOutputs({ userId, spendable: true })
                const balance1 = sum(allSpendableOutputs, v => v.amount || 0)
                console.log(`  ${balance1} balance1, sum of spendable outputs`)

                const txs = await storage.findTransactions({ status: 'completed', userId }) // , undefined, { limit, offset });
                const balance2 = sum(txs, v => v.amount || 0)
                console.log(`  ${balance2} balance2, sum of completed transaction amounts`)

                for (const tx of txs) if (tx.rawTransaction) {

                    const tid = verifyId(tx.transactionId)

                    const commissions = await storage.findCommissions({ transactionId: tid })
                    const commissionsSum = sum(commissions, v => v.satoshis)

                    const inputOutpts = await storage.findOutputs({ spentBy: tid })
                    const inputOutputsSum = sum(inputOutpts, v => v.amount || 0)

                    const os = await storage.findOutputs({ transactionId: tid })
                    const owned = filter(os, v => v.userId === tx.userId)
                    const ownedChange = filter(owned.ts, v => v.change || v.purpose === 'change')
                    const myChange = sum(ownedChange.ts, v => v.amount || 0)




                    const txBsv = asBsvSdkTx(tx.rawTransaction)
                    const txIns = txBsv.inputs
                    const txOuts = txBsv.outputs
                    //const totalIn = txIns.reduce((a, e) => a + e.)
                }

                if (txs.length < limit)
                    break;
                offset += limit
            }
        }
    }

}

function sum<T>(a: T[], getNum: (v: T) => number) : number {
    let s = 0
    for (const v of a) s += getNum(v)
    return s
}

function filter<T>(a: T[], pred: (v: T) => boolean) : { ts: T[], fs: T[] } {
    const ts: T[] = []
    const fs: T[] = []
    for (const v of a) if (pred(v)) ts.push(v); else fs.push(v)
    return { ts, fs }
}

export interface DojoWatchmanOptions extends CwiExternalServicesOptions {
    /**
     * How many msecs to wait after each getMerkleProof service request.
     */
    msecsWaitPerMerkleProofServiceReq: number
    
    taskRunWaitMsecs: number
    
    abandonedMsecs: number

    unprovenAttemptsLimitTest: number

    unprovenAttemptsLimitMain: number
}